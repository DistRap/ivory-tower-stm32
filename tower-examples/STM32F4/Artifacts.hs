
module Artifacts where

import Interrupt

linker_script :: String
linker_script = unlines $
  [ ""
  , "MEMORY"
  , "{"
  , "#ifdef CONFIG_STM32F4_BOOTLOADER"
  , "  flash (rx) : ORIGIN = 0x08004000, LENGTH = 1008K"
  , "#else"
  , "  flash (rx) : ORIGIN = 0x08000000, LENGTH = 1024K"
  , "#endif"
  , "  sram (rwx) : ORIGIN = 0x20000000, LENGTH = 128K"
  , "  ccsram (rwx) : ORIGIN = 0x10000000, LENGTH = 64K"
  , "}"
  , ""
    -- Top of the initial user mode stack.
  , "_estack = 0x20020000;"
    -- Error in linker of heap and stack dont fit.
  , "_min_heap_size = 0;"
  , "_min_stack_size = 0x400;"
  , ""
  , "OUTPUT_ARCH(arm)"
  , "ENTRY(isrResetException)"
  , ""
  , "SECTIONS"
  , "{"
  , ""
  ,  foldl (\acc s -> acc ++ "\n\t" ++ s) "" sections
  , ""
  , "}"
  ]

sections :: [String]
sections =
  [ ".stm32f4_vectors: {"
  , "  . = ALIGN (4);"
  , "  KEEP(*(.stm32f4_vectors))"
  , "  . = ALIGN (4);"
  , "} > flash"
  , ""
  , ".text : {"
  , "  *(.text .text.*)"
  , "  *(.fixup)"
  , "  *(.gnu.warning)"
  , "  *(.rodata .rodata.*)"
  , "  *(.glue_7)"
  , "  *(.glue_7t)"
  , "  *(.eh_frame)"
  , "  *(.gnu.linkonce.t.*)"
  , "  *(.got)"
  , "  *(.gcc_except_table)"
  , "  *(.gnu.linkonce.r.*)"
  , ""
  , "  KEEP(*(.init))"
  , "  KEEP(*(.fini))"
  , ""
  , "  . = ALIGN(4);"
  , "  _etext = ABSOLUTE(.);"
  , "} > flash"
  , ""
  , ".ARM.extab : {"
  , "  *(.ARM.extab*)"
  , "} > flash"
  , ""
  , "__exidx_start = ABSOLUTE(.);"
  , ".ARM.exidx : {"
  , "  *(.ARM.exidx*)"
  , "} > flash"
  , "__exidx_end = ABSOLUTE(.);"
  , ""
  , ".preinit_array : {"
  , "  PROVIDE_HIDDEN(__preinit_array_start = .);"
  , "  KEEP(*(.preinit_array))"
  , "  PROVIDE_HIDDEN(__preinit_array_end = .);"
  , "} > flash"
  , ""
  , ".init_array : {"
  , "  PROVIDE_HIDDEN(__init_array_start = .);"
  , "  KEEP(*(.init_array))"
  , "  PROVIDE_HIDDEN(__init_array_end = .);"
  , "} > flash"
  , ""
  , ".ctors : {"
  , "  KEEP(*crtbegin.o(.ctors))"
  , "  KEEP(*crtbegin?.o(.ctors))"
  , "  KEEP(*(EXCLUDE_FILE(*crtend.o *crtend?.o) .ctors))"
  , "  KEEP(*(SORT(.ctors.*)))"
  , "  KEEP(*(.ctors))"
  , "} > flash"
  , ""
  , ".data : {"
  , "  _sidata = LOADADDR(.data);"
  , "  _sdata = ABSOLUTE(.);"
  , "  *(.data .data.*)"
  , "  *(.gnu.linkonce.d.*)"
  , "  CONSTRUCTORS"
  , "  _edata = ABSOLUTE(.);"
  , "} > ccsram AT > flash"
  , ""
  , ". = ALIGN(4);"
  , ".bss : {"
  , "  _sbss = ABSOLUTE(.);"
  , "  __bss_start__ = ABSOLUTE(_sbss);"
  , "  *(.bss .bss.*)"
  , "  *(.gnu.linkonce.b.*)"
  , "  *(COMMON)"
  , "  . = ALIGN(4);"
  , "  _ebss = ABSOLUTE(.);"
  , "  __bss_end__ = ABSOLUTE(_ebss);"
  , "} > sram"
  , ""
  , "._user_heap_stack : {"
  , "  . = ALIGN(4);"
  , "  PROVIDE(end = .);"
  , "  PROVIDE(_end = .);"
  , "  . = . + _min_heap_size;"
  , "  . = . + _min_stack_size;"
  , "  . = ALIGN(4);"
  , "} > ccsram"
  , ""
  , "/* Stabs debugging sections. */"
  , ".stab 0 : { *(.stab) }"
  , ".stabstr 0 : { *(.stabstr) }"
  , ".stab.excl 0 : { *(.stab.excl) }"
  , ".stab.exclstr 0 : { *(.stab.exclstr) }"
  , ".stab.index 0 : { *(.stab.index) }"
  , ".stab.indexstr 0 : { *(.stab.indexstr) }"
  , ".comment 0 : { *(.comment) }"
  , ".debug_abbrev 0 : { *(.debug_abbrev) }"
  , ".debug_info 0 : { *(.debug_info) }"
  , ".debug_line 0 : { *(.debug_line) }"
  , ".debug_pubnames 0 : { *(.debug_pubnames) }"
  , ".debug_aranges 0 : { *(.debug_aranges) }"
  , ""
  , "/DISCARD/ : {"
  , "  libc.a (*)"
  , "  libm.a (*)"
  , "  libgcc.a (*)"
  ]

vector_table :: String
vector_table = unlines $
  [ ""
  , ""
  , "\t.syntax unfiied"
  , "\t.thumb"
  , "\t.cpu cortex-m3"
  , "\t.fpu softvfp"

  , ".global isrResetException"
  , ".global stm32f4_vectors"
  , ".word _sidata"
  , ".word _sdata"
  , ".word _edata"
  , ".word _sbss"
  , ".word _ebss"

  , "\t.section .text.isrDefaultExceptionHandler, \"ax\",%progbits"
  , "isrDefaultExceptionHandler:"
  , "\tb isrDefaultExceptionHandler"
  , "\t.size isrDefaultExceptionHandler, .-DefaultExceptionHandler"
  , ""
  , "\t.section .vectors \"ax\""
  , "\t.code    16"
  , "\t.align   2"
  , "\t.globl   stm32f4_vectors"
  , "\t.type    stm32f4_vectors, function"
  , ""
  , "stm32f4_vectors:"
  , ""
  , entry "(_estack+0x400)"
  , entry "isrResetException"
  ] ++
  map (entry . isrException) (enumFrom NonMaskable) ++
  map (entry . isrInterrupt) (enumFrom WWDG) ++
  [ ""
  , "\t.size stm32f4_vectors, .-stm32f4_vectors"
  , ""
  ] ++
  map (weakdef . isrException) (enumFrom NonMaskable) ++
  map (weakdef . isrInterrupt) (enumFrom WWDG)

  where
  entry e = "\t.word " ++ e
  weakdef handler = "\t.weak " ++ handler ++ "\n\t.thumb_set " ++ handler ++ ",isrDefaultExceptionHandler\n"

{- DEPRECATED - should fix this later
  signalArtifacts = const $
    [ Artifact { artifact_filepath = "stm32f4_flash.lds.S"
               , artifact_contents = linker_script
               }
    , Artifact { artifact_filepath = "stm42f4_vectors.s"
               , artifact_contents = vector_table
               }
    ]
-}
