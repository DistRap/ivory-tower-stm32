{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}


module CheckerTask (
  checkerTask
  ) where


import Types

import Ivory.Tower
import Ivory.Language

--------------------------------------------------------------------------------

-- What to do if a property fails (in this case, led_set(1, 1))?
action :: Def ('[Sint32, IBool] :-> ())
action = importProc "led_set" "hwf4/led.h"

append_to_history :: Def ('[Ix 100, Uint32] :-> ())
append_to_history = importProc "append_to_history" "instrumented.h"

-- -- XXX Seems cool to redefine imported types...
-- append_to_history' :: Def ('[Ix 100, Uint16] :-> ())
-- append_to_history' = importProc "append_to_history" "instrumented.h"

--------------------------------------------------------------------------------

mkHistory :: Def ('[AssignRef s] :-> ())
mkHistory = proc "mkHistory" $ \s -> body $ do
  var <- deref (s ~> var_id)
  val <- deref (s ~> value)
  call_ append_to_history var val

--------------------------------------------------------------------------------

-- "check_properties" is automatically generated by the RTV system and always
-- has the same type.  We just have to call it and see if it's true.
check_properties :: Def ('[] :-> IBool)
check_properties = importProc "check_properties" "runtime-checker.h"

runCheck :: Ivory s ()
runCheck = do
  bool <- call check_properties
  ifte bool (return ()) (call_ action 1 true)

--------------------------------------------------------------------------------

-- Checker task
checkerTask :: ChannelSink AssignStruct -> Task ()
checkerTask sink = do
  -- "src" string only is for graphviz output for now
  rx <- withChannelReceiver sink "rvSink"
  taskModuleDef $ \_sch -> defStruct (Proxy :: Proxy "assignment")
  taskModuleDef $ \_sch -> incl mkHistory
  taskModuleDef $ \_sch -> incl action
  taskBody $ \sch -> do
    eventLoop sch $ onChannel rx $ \latestVal -> do
      call_ mkHistory latestVal
      runCheck

--------------------------------------------------------------------------------
