Read serial, perform encryption/decryption, and pass data between mavproxy.py
and SMACCMPilot.

--------------------------------------------------------------------------------
-- Directory structure
--------------------------------------------------------------------------------

* mavlink: submodule containing mavproxy.py, the open-source ground station for
  interpreting and generating mavlink messages.

* src: smaccmpilot-specific code.


--------------------------------------------------------------------------------
-- Architecture
--------------------------------------------------------------------------------

            ------------  TCP  ------------------
            | mavproxy |  -->  | commsec-server |
            ------------  <--  ------------------

  Serial ---------------- air ---------------- UART
   -->   | smaccm-radio | --> | smaccm-radio | -->
   <--   ---------------- <-- ---------------- <--

                    ---------------
                    | SMACCMPilot |
                    ---------------

--------------------------------------------------------------------------------
-- Message framing
--------------------------------------------------------------------------------

Over the air, the radios have their own protocol to frame bytes and perform
error checks.  We will ensure that each message fits within a single air frame.
The benfit of doing so is that if an air frame is corrupted, that corruption
affects a single message.  All MAVLink packets are 80 bytes (shorter messages
are padded with 0-bytes).  The air frames are around

Encrypted messages (or a "package") is an instance of Galois/Counter Mode
(AES-GCM) <http://en.wikipedia.org/wiki/Galois/Counter_Mode>.  A package to be
sent on the wire contains the header, consisting of an identifier (4 bytes) and
a counter (4 bytes), the encrypted message itself, and an authentication tag (8
bytes):

  -------------------------
  | id | cntr | msg | tag |
  -------------------------

In our case, messages are Mavlink packets.  Thus, commsec payloads are 80+16 bytes.

Independent of our crypto implementation, we use a simple framing protocol for
framing between the radio and the ground station and between radio and the
autopilot respectively (or if you are testing over serial on the bench, between
the autopilot and GCS).  The purpose of using the framing protocol is to provide
a framing protocol at the link-level independent of MAVLink or a particular
crypto algorithm.

The protocol marks frame boundaries and does no error detection or correction.
Thus, the protocol should only be used in transmissions that can be reasonably
assumed to have zero loss rates.

In the framing protocol, the special byte (0x7e) marks the beginning of the
frame, and a frame includes all bytes until a new begin-frame marker is
encountered.  The first byte of a frame is the frame tag.  Our current tags are
0 to mark air-data messages (messages between the autopilot and the GCS) and 1
to mark radio messages (unencrypted messages to be parsed by the radio).

0x73 is an escape byte, in case 0x7e or 0x73 are encountered in
the message:

  ---------------------------------------------
  | 0x7e | tag | frame0 | 0x7e | tag | frame1 |
  ---------------------------------------------
